package kaze

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/sdslabs/gasper/configs"
	"github.com/sdslabs/gasper/lib/commons"
	"github.com/sdslabs/gasper/lib/mongo"
	"github.com/sdslabs/gasper/lib/redis"
	"github.com/sdslabs/gasper/lib/utils"
	"github.com/sdslabs/gasper/types"
)

// rescheduleInstance redeploys down instances on least loaded servers
func rescheduleInstance(apps []types.M, service string) {
	if len(apps) == 0 {
		return
	}

	// distributionArray stores the number of more apps each instance can hold
	// scoreArray and URLArray stores the urls of the instances and the corresponding urls
	var distributionArray, scoreArray []int
	var URLArray []string

	// fetch n least loaded mizu instances
	n := len(apps)
	instances, err := redis.GetLeastLoadedInstancesWithScores(redis.WorkerInstanceKey, int64(n))
	if err != nil {
		utils.LogError(err)
	}

	for _, instance := range instances {
		if instance != redis.ErrEmptySet {
			instanceUnits := strings.Split(instance, ":")
			score, err := strconv.Atoi(instanceUnits[2])
			if err != nil {
				utils.LogError(err)
			}
			scoreArray = append(scoreArray, score)

			url := instanceUnits[0] + ":" + instanceUnits[1]
			URLArray = append(URLArray, url)
		}
	}

	deployedApps := n
	level := scoreArray[0]

	// generate the distributionArray based the corresponding scores(loads)
	for deployedApps > 0 {
		for i := 0; ; i++ {
			if level == scoreArray[i] {
				deployedApps--
				scoreArray[i]++
				distributionArray[i]++
			} else {
				level++
				break
			}
		}
	}

	var index int

	// deploy the apps based on the distribution generated by the distributionArray
	for _, app := range apps {
		instanceURL := URLArray[index]
		scoreArray[index]--
		if scoreArray[index] <= 0 {
			index++
		}

		commons.DeployRPC(app, instanceURL, service)
	}
}

// inspectInstance checks whether a given instance is alive or not and deletes that instance
// if it is dead
func inspectInstance(service, instance string) {
	// Handle Hikari's health-check by sending a UDP probe instead of TCP
	if service == types.Hikari {
		if !utils.IsHikariAlive(instance) {
			if err := redis.RemoveServiceInstance(service, instance); err != nil {
				utils.LogError(err)
			}
		}
		return
	}
	if utils.NotAlive(instance) {
		if err := redis.RemoveServiceInstance(service, instance); err != nil {
			utils.LogError(err)
		}
		// Re-schedule applications for Mizu microservice
		if service == types.Mizu {
			if !strings.Contains(instance, ":") {
				utils.LogError(fmt.Errorf("Instance %s is in invalid format", instance))
				return
			}
			instanceIP := strings.Split(instance, ":")[0]
			apps := mongo.FetchAppInfo(types.M{
				mongo.HostIPKey: instanceIP,
			},
			)
			go rescheduleInstance(apps, service)
		}
	}
}

// removeDeadServiceInstances removes all inactive instances in a given service
func removeDeadServiceInstances(service string) {
	instances, err := redis.FetchServiceInstances(service)
	if err != nil {
		utils.LogError(err)
	}
	for _, instance := range instances {
		go inspectInstance(service, instance)
	}
}

// removeDeadInstances removes all inactive instances in every service
func removeDeadInstances() {
	time.Sleep(5 * time.Second)
	for service := range configs.ServiceMap {
		go removeDeadServiceInstances(service)
	}
}

// ScheduleCleanup runs removeDeadInstances on given intervals of time
func ScheduleCleanup() {
	time.Sleep(10 * time.Second)
	interval := configs.ServiceConfig.Kaze.CleanupInterval * time.Second
	scheduler := utils.NewScheduler(interval, removeDeadInstances)
	scheduler.RunAsync()
}
